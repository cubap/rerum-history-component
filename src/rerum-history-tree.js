// RERUM History Tree Web Component\n// Fetches the appropriate /history/{id} endpoint and renders a collapsible tree.\n// If api-base ends with /id, we derive the history base by replacing /id with /history.\n// You can override with the history-base attribute.\n// Heuristics for id and parent/child linkage are documented in README.md.\n\nconst TEMPLATE = document.createElement('template');\nTEMPLATE.innerHTML = `\n  <style>\n    :host {\n      --rht-font-size: 14px;\n      --rht-line-height: 1.35;\n      --rht-accent: #2563eb; /* indigo-600 */\n      --rht-muted: #6b7280;  /* gray-500 */\n      --rht-border: #e5e7eb; /* gray-200 */\n      --rht-bg: #fff;\n      --rht-hover: #f9fafb;\n\n      display: block;\n      font-size: var(--rht-font-size);\n      line-height: var(--rht-line-height);\n      color: #111827; /* gray-900 */\n      background: var(--rht-bg);\n    }\n    .header {\n      display: flex;\n      gap: .5rem;\n      align-items: baseline;\n      margin-bottom: .5rem;\n      flex-wrap: wrap;\n    }\n    .header code {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\n      background: #f3f4f6;\n      padding: 0 .35rem;\n      border-radius: 4px;\n      border: 1px solid var(--rht-border);\n      color: #111827;\n    }\n    .tree {\n      padding-left: .25rem;\n    }\n    details {\n      border-left: 2px solid var(--rht-border);\n      margin: .125rem 0 .125rem .5rem;\n      padding-left: .5rem;\n    }\n    summary {\n      list-style: none;\n      cursor: pointer;\n      padding: .1rem .25rem;\n      border-radius: 6px;\n      display: inline-flex;\n      align-items: center;\n      gap: .4rem;\n    }\n    summary::-webkit-details-marker { display: none; }\n    summary:hover { background: var(--rht-hover); }\n    .twisty {\n      width: .9em;\n      display: inline-flex;\n      transform: rotate(-90deg);\n      transition: transform .12s ease;\n      color: var(--rht-muted);\n    }\n    details[open] > summary .twisty {\n      transform: rotate(0deg);\n      color: var(--rht-accent);\n    }\n    .label {\n      font-weight: 500;\n    }\n    .meta {\n      color: var(--rht-muted);\n      font-size: 0.92em;\n    }\n    .leaf {\n      margin: .125rem 0 .125rem 1.5rem;\n      padding: .1rem .25rem;\n      border-radius: 6px;\n    }\n    .leaf:hover { background: var(--rht-hover); }\n    .id {\n      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\n      color: #374151;\n      word-break: break-all;\n    }\n    .error {\n      color: #b91c1c;\n      background: #fef2f2;\n      border: 1px solid #fecaca;\n      padding: .5rem .75rem;\n      border-radius: 8px;\n    }\n    .sr-only {\n      position: absolute;\n      width: 1px;\n      height: 1px;\n      padding: 0;\n      margin: -1px;\n      overflow: hidden;\n      clip: rect(0,0,0,0);\n      border: 0;\n    }\n  </style>\n  <div class="header">\n    <div><strong>RERUM History</strong></div>\n    <div class="meta">\n      <span class="sr-only">Base: </span><code id="baseDisplay"></code>\n      <span>•</span>\n      <span class="sr-only">Document ID: </span><code id="docIdDisplay"></code>\n    </div>\n  </div>\n  <div id="content"></div>\n`;\n\nexport class RerumHistoryTree extends HTMLElement {\n  static get observedAttributes() {\n    return ['api-base', 'history-base', 'document-id', 'node-label-key'];\n  }\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' }).appendChild(TEMPLATE.content.cloneNode(true));\n    this._state = {\n      items: [],\n      graph: null\n    };\n    this._abort = null;\n  }\n\n  connectedCallback() {\n    this._renderHeader();\n    if (this.apiBase && this.documentId) {\n      this.refresh();\n    }\n  }\n\n  attributeChangedCallback(name, oldVal, newVal) {\n    if (oldVal === newVal) return;\n    if (name === 'api-base' || name === 'history-base' || name === 'document-id') {\n      this._renderHeader();\n      if (this.isConnected && this.apiBase && this.documentId) {\n        this.refresh();\n      }\n    } else if (name === 'node-label-key' && this._state.items?.length) {\n      this._renderTree();\n    }\n  }\n\n  get apiBase() {\n    return (this.getAttribute('api-base') || '').replace(/\/+$/, '');\n  }\n  set apiBase(v) {\n    if (v == null) this.removeAttribute('api-base');\n    else this.setAttribute('api-base', v);\n  }\n\n  get historyBase() {\n    return (this.getAttribute('history-base') || '').replace(/\/+$/, '');\n  }\n  set historyBase(v) {\n    if (!v) this.removeAttribute('history-base');\n    else this.setAttribute('history-base', v);\n  }\n\n  get documentId() {\n    return this.getAttribute('document-id') || '';\n  }\n  set documentId(v) {\n    if (v == null) this.removeAttribute('document-id');\n    else this.setAttribute('document-id', v);\n  }\n\n  get nodeLabelKey() {\n    return this.getAttribute('node-label-key') || '';\n  }\n  set nodeLabelKey(v) {\n    if (!v) this.removeAttribute('node-label-key');\n    else this.setAttribute('node-label-key', v);\n  }\n\n  _deriveHistoryBase() {\n    if (this.historyBase) return this.historyBase;\n    const base = this.apiBase;\n    if (!base) return '';\n    // If base ends with /id, replace with /history\n    const replaced = base.replace(/\/id\/?$/, '/history');\n    if (replaced !== base) return replaced;\n    // Otherwise, append /history\n    return `${base}/history`;\n  }\n\n  async refresh() {\n    if (!this.apiBase || !this.documentId) return;\n    this._clearAbort();\n    const controller = new AbortController();\n    this._abort = controller;\n\n    const historyBase = this._deriveHistoryBase();\n    const url = `${historyBase}/${encodeURIComponent(this.documentId)}`;\n    this._setContent(this._infoEl(`Loading history…`));\n\n    try {\n      const res = await fetch(url, { signal: controller.signal, headers: { accept: 'application/json' } });\n      if (!res.ok) throw new Error(`Request failed (${res.status}) ${res.statusText}`);\n      const data = await res.json();\n\n      const rawItems = Array.isArray(data) ? data : (data?.items || data?.history || []);\n      if (!Array.isArray(rawItems)) {\n        throw new Error('Unexpected response format (expected array).');\n      }\n\n      const items = rawItems.map((it) => (typeof it === 'string' ? { '@id': it } : it));\n      this._state.items = items;\n      this._state.graph = buildGraph(items);\n\n      this._renderTree();\n\n      this.dispatchEvent(new CustomEvent('loaded', {\n        detail: { count: items.length, roots: this._state.graph.roots },\n        bubbles: true\n      }));\n    } catch (error) {\n      if (error.name === 'AbortError') return;\n      this._setContent(this._errorEl(error));\n      this.dispatchEvent(new CustomEvent('error', { detail: { error }, bubbles: true }));\n    } finally {\n      this._clearAbort();\n    }\n  }\n\n  _renderHeader() {\n    const root = this.shadowRoot;\n    const base = this.historyBase || this.apiBase;\n    root.getElementById('baseDisplay').textContent = base || '(no base)';\n    root.getElementById('docIdDisplay').textContent = this.documentId || '(no document id)';\n  }\n\n  _renderTree() {\n    const container = document.createElement('div');\n    container.className = 'tree';\n\n    const { nodes, children, roots, idFor } = this._state.graph || {};\n    if (!nodes) {\n      this._setContent(this._errorEl(new Error('No graph to render.')));\n      return;\n    }\n\n    if (roots.length === 0) {\n      container.appendChild(this._infoEl('No roots found. Rendering all as leaves.'));\n      for (const item of this._state.items) {\n        container.appendChild(this._leafEl(item, idFor(item)));\n      }\n      this._setContent(container);\n      return;\n    }\n\n    for (const rootId of roots) {\n      const el = this._branchEl(nodes.get(rootId), rootId, children, nodes, idFor, 0);\n      container.appendChild(el);\n    }\n\n    this._setContent(container);\n  }\n\n  _branchEl(item, id, childrenMap, nodes, idFor, depth) {\n    const kids = childrenMap.get(id) || [];\n    const details = document.createElement('details');\n    if (depth < 2) details.open = true;\n\n    const summary = document.createElement('summary');\n    const twisty = document.createElement('span');\n    twisty.className = 'twisty';\n    twisty.textContent = '▶';\n    const label = document.createElement('span');\n    label.className = 'label';\n    label.textContent = this._labelFor(item, id);\n    const idEl = document.createElement('span');\n    idEl.className = 'id meta';\n    idEl.textContent = `(${id})`;\n\n    summary.appendChild(twisty);\n    summary.appendChild(label);\n    summary.appendChild(idEl);\n    summary.addEventListener('click', (e) => {\n      this.dispatchEvent(new CustomEvent('nodeclick', {\n        detail: { id, item },\n        bubbles: true\n      }));\n      e.stopPropagation();\n    });\n\n    details.appendChild(summary);\n\n    for (const childId of kids) {\n      const child = nodes.get(childId);\n      const childKids = (childrenMap.get(childId) || []);\n      if (childKids.length > 0) {\n        details.appendChild(this._branchEl(child, childId, childrenMap, nodes, idFor, depth + 1));\n      } else {\n        details.appendChild(this._leafEl(child, childId));\n      }\n    }\n    return details;\n  }\n\n  _leafEl(item, id) {\n    const leaf = document.createElement('div');\n    leaf.className = 'leaf';\n    leaf.innerHTML = `\n      <span class="label">${escapeHtml(this._labelFor(item, id))}</span>\n      <span class="id meta">(${escapeHtml(id)})</span>\n    `;\n    leaf.addEventListener('click', (e) => {\n      this.dispatchEvent(new CustomEvent('nodeclick', {\n        detail: { id, item },\n        bubbles: true\n      }));\n      e.stopPropagation();\n    });\n    return leaf;\n  }\n\n  _labelFor(item, id) {\n    const key = this.nodeLabelKey?.trim();\n    if (key && item && typeof item === 'object' && key in item) {\n      const v = item[key];\n      if (v != null) return String(v);\n    }\n    if (item?.label) return String(item.label);\n    if (item?.name) return String(item.name);\n    if (id) {\n      try {\n        const u = new URL(String(id), window.location.href);\n        const segs = u.pathname.split('/').filter(Boolean);\n        if (segs.length) return segs[segs.length - 1];\n      } catch {\n        const segs = String(id).split(/[\/#!]/).filter(Boolean);\n        if (segs.length) return segs[segs.length - 1];\n      }\n    }\n    return 'version';\n  }\n\n  _infoEl(msg) {\n    const d = document.createElement('div');\n    d.className = 'meta';\n    d.textContent = msg;\n    return d;\n  }\n  _errorEl(error) {\n    const d = document.createElement('div');\n    d.className = 'error';\n    d.textContent = `Error: ${error?.message || error}`;\n    return d;\n  }\n  _setContent(node) {\n    const content = this.shadowRoot.getElementById('content');\n    content.innerHTML = '';\n    content.appendChild(node);\n  }\n  _clearAbort() {\n    if (this._abort) {\n      this._abort.abort();\n      this._abort = null;\n    }\n  }\n}\n\ncustomElements.define('rerum-history-tree', RerumHistoryTree);\n\n/**\n * Build a graph from items using heuristics:\n * - idFor: @id || id || _id (falls back to __rerum.history.id || __rerum.id)\n * - parentFrom(item): __rerum.history.previous (string or object)\n * - nextFrom(item): __rerum.history.next (array of ids)\n */\nfunction buildGraph(items) {\n  const nodes = new Map();\n  const idFor = (item) => idFrom(item);\n  for (const it of items) {\n    const id = idFor(it);\n    if (!id) continue;\n    nodes.set(id, it);\n  }\n\n  const children = new Map();\n  const allChildren = new Set();\n  const ensure = (id) => { if (!children.has(id)) children.set(id, new Set()); return children.get(id); };\n\n  // previous -> child\n  for (const it of items) {\n    const childId = idFor(it);\n    if (!childId) continue;\n\n    const prev = previousFrom(it);\n    const parentId = normalizeId(prev);\n    if (parentId) {\n      ensure(parentId).add(childId);\n      allChildren.add(childId);\n    }\n  }\n\n  // next array -> children\n  for (const it of items) {\n    const parentId = idFor(it);\n    if (!parentId) continue;\n\n    const nexts = nextFrom(it);\n    if (Array.isArray(nexts)) {\n      for (const nxt of nexts) {\n        const cid = normalizeId(nxt);\n        if (!cid) continue;\n        ensure(parentId).add(cid);\n        allChildren.add(cid);\n      }\n    }\n  }\n\n  // Convert child sets to arrays and filter to known nodes\n  const childrenArr = new Map();\n  for (const [pid, set] of children.entries()) {\n    childrenArr.set(pid, Array.from(set).filter((cid) => nodes.has(cid)));\n  }\n\n  // Roots = nodes that are not a child of any other node\n  const roots = [];\n  for (const id of nodes.keys()) {\n    if (!allChildren.has(id)) roots.push(id);\n  }\n\n  return { nodes, children: childrenArr, roots, idFor };\n}\n\nfunction idFrom(item) {\n  if (!item || typeof item !== 'object') return '';\n  if (typeof item['@id'] === 'string') return item['@id'];\n  if (typeof item.id === 'string') return item.id;\n  if (typeof item._id === 'string') return item._id;\n  const nested = item?.__rerum?.history?.id || item?.__rerum?.id;\n  if (typeof nested === 'string') return nested;\n  return '';\n}\n\nfunction previousFrom(item) {\n  const prev = item?.__rerum?.history?.previous ?? item?.history?.previous ?? item?.__rerum?.previous;\n  return prev;\n}\n\nfunction nextFrom(item) {\n  const nxt = item?.__rerum?.history?.next ?? item?.history?.next ?? item?.__rerum?.next;\n  return Array.isArray(nxt) ? nxt : (typeof nxt === 'string' ? [nxt] : null);\n}\n\nfunction normalizeId(value) {\n  if (!value) return '';\n  if (typeof value === 'string') return value;\n  if (typeof value === 'object') return idFrom(value);\n  return '';\n}\n\nfunction escapeHtml(s) {\n  return String(s)\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('"', '&quot;')\n    .replaceAll("'", '&#039;');\n}